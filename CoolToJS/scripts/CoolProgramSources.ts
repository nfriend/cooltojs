module CoolToJS.CoolProgramSources {
    export var List = '(*\r\n *  This file shows how to implement a list data type for lists of integers.\r\n *  It makes use of INHERITANCE and DYNAMIC DISPATCH.\r\n *\r\n *  The List class has 4 operations defined on List objects. If \'l\' is\r\n *  a list, then the methods dispatched on \'l\' have the following effects:\r\n *\r\n *    isNil() : Bool\t\tReturns true if \'l\' is empty, false otherwise.\r\n *    head()  : Int\t\tReturns the integer at the head of \'l\'.\r\n *\t\t\t\tIf \'l\' is empty, execution aborts.\r\n *    tail()  : List\t\tReturns the remainder of the \'l\',\r\n *\t\t\t\ti.e. without the first element.\r\n *    cons(i : Int) : List\tReturn a new list containing i as the\r\n *\t\t\t\tfirst element, followed by the\r\n *\t\t\t\telements in \'l\'.\r\n *\r\n *  There are 2 kinds of lists, the empty list and a non-empty\r\n *  list. We can think of the non-empty list as a specialization of\r\n *  the empty list.\r\n *  The class List defines the operations on empty list. The class\r\n *  Cons inherits from List and redefines things to handle non-empty\r\n *  lists.\r\n *)\r\n\r\n\r\nclass List {\r\n   -- Define operations on empty lists.\r\n\r\n   isNil() : Bool { true };\r\n\r\n   -- Since abort() has return type Object and head() has return type\r\n   -- Int, we need to have an Int as the result of the method body,\r\n   -- even though abort() never returns.\r\n\r\n   head()  : Int { { abort(); 0; } };\r\n\r\n   -- As for head(), the self is just to make sure the return type of\r\n   -- tail() is correct.\r\n\r\n   tail()  : List { { abort(); self; } };\r\n\r\n   -- When we cons and element onto the empty list we get a non-empty\r\n   -- list. The (new Cons) expression creates a new list cell of class\r\n   -- Cons, which is initialized by a dispatch to init().\r\n   -- The result of init() is an element of class Cons, but it\r\n   -- conforms to the return type List, because Cons is a subclass of\r\n   -- List.\r\n\r\n   cons(i : Int) : List {\r\n      (new Cons).init(i, self)\r\n   };\r\n\r\n};\r\n\r\n\r\n(*\r\n *  Cons inherits all operations from List. We can reuse only the cons\r\n *  method though, because adding an element to the front of an emtpy\r\n *  list is the same as adding it to the front of a non empty\r\n *  list. All other methods have to be redefined, since the behaviour\r\n *  for them is different from the empty list.\r\n *\r\n *  Cons needs two attributes to hold the integer of this list\r\n *  cell and to hold the rest of the list.\r\n *\r\n *  The init() method is used by the cons() method to initialize the\r\n *  cell.\r\n *)\r\n\r\nclass Cons inherits List {\r\n\r\n   car : Int;\t-- The element in this list cell\r\n\r\n   cdr : List;\t-- The rest of the list\r\n\r\n   isNil() : Bool { false };\r\n\r\n   head()  : Int { car };\r\n\r\n   tail()  : List { cdr };\r\n\r\n   init(i : Int, rest : List) : List {\r\n      {\r\n\t car <- i;\r\n\t cdr <- rest;\r\n\t self;\r\n      }\r\n   };\r\n\r\n};\r\n\r\n\r\n\r\n(*\r\n *  The Main class shows how to use the List class. It creates a small\r\n *  list and then repeatedly prints out its elements and takes off the\r\n *  first element of the list.\r\n *)\r\n\r\nclass Main inherits IO {\r\n\r\n   mylist : List;\r\n\r\n   -- Print all elements of the list. Calls itself recursively with\r\n   -- the tail of the list, until the end of the list is reached.\r\n\r\n   print_list(l : List) : Object {\r\n      if l.isNil() then out_string(\"\\n\")\r\n                   else {\r\n\t\t\t   out_int(l.head());\r\n\t\t\t   out_string(\" \");\r\n\t\t\t   print_list(l.tail());\r\n\t\t        }\r\n      fi\r\n   };\r\n\r\n   -- Note how the dynamic dispatch mechanism is responsible to end\r\n   -- the while loop. As long as mylist is bound to an object of \r\n   -- dynamic type Cons, the dispatch to isNil calls the isNil method of\r\n   -- the Cons class, which returns false. However when we reach the\r\n   -- end of the list, mylist gets bound to the object that was\r\n   -- created by the (new List) expression. This object is of dynamic type\r\n   -- List, and thus the method isNil in the List class is called and\r\n   -- returns true.\r\n\r\n   main() : Object {\r\n      {\r\n\t mylist <- new List.cons(1).cons(2).cons(3).cons(4).cons(5);\r\n\t while (not mylist.isNil()) loop\r\n\t    {\r\n\t       print_list(mylist);\r\n\t       mylist <- mylist.tail();\r\n\t    }\r\n\t pool;\r\n      }\r\n   };\r\n\r\n};';
    export var HelloWorld = 'class Main inherits IO {\r\n\tmain() : Object {\r\n\t\tout_string(\"Hello, world.\\n\")\r\n\t};\r\n};';
    export var Atoi = '(*\r\n   The class A2I provides integer-to-string and string-to-integer\r\nconversion routines.  To use these routines, either inherit them\r\nin the class where needed, have a dummy variable bound to\r\nsomething of type A2I, or simpl write (new A2I).method(argument).\r\n*)\r\n\r\n\r\n(*\r\n   c2i   Converts a 1-character string to an integer.  Aborts\r\n         if the string is not \"0\" through \"9\"\r\n*)\r\nclass A2I {\r\n\r\n     c2i(char : String) : Int {\r\n\tif char = \"0\" then 0 else\r\n\tif char = \"1\" then 1 else\r\n\tif char = \"2\" then 2 else\r\n        if char = \"3\" then 3 else\r\n        if char = \"4\" then 4 else\r\n        if char = \"5\" then 5 else\r\n        if char = \"6\" then 6 else\r\n        if char = \"7\" then 7 else\r\n        if char = \"8\" then 8 else\r\n        if char = \"9\" then 9 else\r\n        { abort(); 0; }  -- the 0 is needed to satisfy the typchecker\r\n        fi fi fi fi fi fi fi fi fi fi\r\n     };\r\n\r\n(*\r\n   i2c is the inverse of c2i.\r\n*)\r\n     i2c(i : Int) : String {\r\n\tif i = 0 then \"0\" else\r\n\tif i = 1 then \"1\" else\r\n\tif i = 2 then \"2\" else\r\n\tif i = 3 then \"3\" else\r\n\tif i = 4 then \"4\" else\r\n\tif i = 5 then \"5\" else\r\n\tif i = 6 then \"6\" else\r\n\tif i = 7 then \"7\" else\r\n\tif i = 8 then \"8\" else\r\n\tif i = 9 then \"9\" else\r\n\t{ abort(); \"\"; }  -- the \"\" is needed to satisfy the typchecker\r\n        fi fi fi fi fi fi fi fi fi fi\r\n     };\r\n\r\n(*\r\n   a2i converts an ASCII string into an integer.  The empty string\r\nis converted to 0.  Signed and unsigned strings are handled.  The\r\nmethod aborts if the string does not represent an integer.  Very\r\nlong strings of digits produce strange answers because of arithmetic \r\noverflow.\r\n\r\n*)\r\n     a2i(s : String) : Int {\r\n        if s.length() = 0 then 0 else\r\n\tif s.substr(0,1) = \"-\" then ~a2i_aux(s.substr(1,s.length()-1)) else\r\n        if s.substr(0,1) = \"+\" then a2i_aux(s.substr(1,s.length()-1)) else\r\n           a2i_aux(s)\r\n        fi fi fi\r\n     };\r\n\r\n(*\r\n  a2i_aux converts the usigned portion of the string.  As a programming\r\nexample, this method is written iteratively.\r\n*)\r\n     a2i_aux(s : String) : Int {\r\n\t(let int : Int <- 0 in\t\r\n           {\t\r\n               (let j : Int <- s.length() in\r\n\t          (let i : Int <- 0 in\r\n\t\t    while i < j loop\r\n\t\t\t{\r\n\t\t\t    int <- int * 10 + c2i(s.substr(i,1));\r\n\t\t\t    i <- i + 1;\r\n\t\t\t}\r\n\t\t    pool\r\n\t\t  )\r\n\t       );\r\n              int;\r\n\t    }\r\n        )\r\n     };\r\n\r\n(*\r\n    i2a converts an integer to a string.  Positive and negative \r\nnumbers are handled correctly.  \r\n*)\r\n    i2a(i : Int) : String {\r\n\tif i = 0 then \"0\" else \r\n        if 0 < i then i2a_aux(i) else\r\n          \"-\".concat(i2a_aux(i * ~1)) \r\n        fi fi\r\n    };\r\n\t\r\n(*\r\n    i2a_aux is an example using recursion.\r\n*)\t\t\r\n    i2a_aux(i : Int) : String {\r\n        if i = 0 then \"\" else \r\n\t    (let next : Int <- i \/ 10 in\r\n\t\ti2a_aux(next).concat(i2c(i - next * 10))\r\n\t    )\r\n        fi\r\n    };\r\n\r\n};';
} 